import { settings, getItem, setItem, localeHHMMSS } from "/scripts/hacking-suite/common.ns";

// Script that controls the various nodes in the server map
//  Can and will use up to the maximum offered ram available

const _settings = settings();
const scripts = {
	hack: `${_settings.baseLocation}hack.ns`,
	grow: `${_settings.baseLocation}grow.ns`,
	weaken: `${_settings.baseLocation}weaken.ns`,
	findServer: `${_settings.baseLocation}find-servers.ns`,
	analyzeMemory: `${_settings.baseLocation}analyze-memory.ns`,
	breakIn: `${_settings.baseLocation}break-in.ns`,
	transfer: `${_settings.baseLocation}transfer.ns`,
	killall: `${_settings.baseLocation}killall.ns`,
}
const hackPrograms = ['BruteSSH.exe', 'FTPCrack.exe', 'relaySMTP.exe', 'HTTPWorm.exe', 'SQLInject.exe',]

/** @param {NS} ns **/
function portsAbleToOpen(ns) {
	let ports = 0;
	for (const program in hackPrograms) {
		if (ns.fileExists(program, 'home'))
			ports++;
	}

	return ports;
}

/** @param {NS} ns **/
function getPlayer(ns) {
	let portCount = portsAbleToOpen(ns);

	hackPrograms.forEach((program) => {
		if (ns.fileExists(program, 'home')) {
			portCount += 1;
		}
	})

	return {
		hackingLevel: ns.getHackingLevel(),
		portCount,
	}
}

/** @param {NS} ns **/
function getHackble(ns, servers) {
	const player = getPlayer(ns);

	const serversOn = Object.keys(servers)
		.filter((hostname) => ns.serverExists(hostname))
		.filter((hostname) => servers[hostname].ports <= player.portCount || ns.hasRootAccess(hostname))
		.map((hostname) => {
			if (hostname !== 'home') {
				if (!ns.hasRootAccess(hostname)) {
					ns.run(scripts.breakIn, 1, hostname);
				}
				ns.run(scripts.transfer, 1, hostname, [scripts.hack, scripts.weaken, scripts.grow]);
			}
			return hostname;
		})
		.filter((hostname) => servers[hostname].ram >= settings.minRamOnServer);

	serversOn.sort((a, b) => servers[a].ram - servers[b].ram);

	return serversOn;
}

/** @param {NS} ns **/
function findTargetServer(ns, serverList, servers, serverExtraData) {
	const player = getPlayer(ns);

	serverList = serverList
		.filter((hostname) => servers[hostname].hackingLevel <= player.hackingLevel)
		.filter((hostname) => servers[hostname].maxMoney)
		.filter((hostname) => hostname !== 'home')
		.filter((hostname) => ns.getWeakenTime(hostname) < settings.maxWeakenTime);

	let weightedSevers = serverList.map((hostname) => {
		const fullHackCycles = Math.ceil(100 / Math.max(0.00000001, ns.hackAnalyzeChance(hostname)))

		serverExtraData[hostname] = {
			fullHackCycles,
		}

		const serverValue = servers[hostname].maxMoney * (settings.minSecurityWeight / (servers[hostname].minSecurityLevel + ns.getServerSecurityLevel(hostname)));

		return {
			hostname,
			serverValue,
			minSecurityLevel: servers[hostname].minSecurityLevel,
			securityLevel: ns.getServerSecurityLevel(hostname),
			maxMoney: servers[hostname].maxMoney,
		}
	})

	weightedSevers.sort((a, b) => b.serverValue - a.serverValue);
	// ns.print(JSON.stringify(weightedServers, null, 2));

	return weightedSevers.map((server) => server.hostname);
}

/** @param {NS} ns **/
function getServerMoneyData(ns, server) {
	let _server = {
		moneyMax: ns.getServerMaxMoney(server),
		money: ns.getServerMoneyAvailable(server) + 1,
		moneyPercent: ((ns.getServerMoneyAvailable(server) + 1) / (ns.getServerMaxMoney(server) + 0.0001) * 100).toFixed(2),
		growth2x: ns.growthAnalyze(server, 2).toFixed(0),
		growth3x: ns.growthAnalyze(server, 3).toFixed(0),
		growth4x: ns.growthAnalyze(server, 4).toFixed(0),
		hack10p: (0.10 / ns.hackAnalyze(server)).toFixed(0),
		hackChance: (ns.hackAnalyzeChance(server) * 100).toFixed(0),
	}
	return _server;
}

/** @param {NS} ns **/
function getTotalMemory(ns, serverMap) {
	let total = 0;

	const servers = Object.keys(serverMap.servers)
		.filter((hostname) => ns.serverExists(hostname))
		.filter((hostname) => hostname !== 'home');

	for (const server of servers) {
		if (ns.hasRootAccess(server))
			total += ns.getServerMaxRam(server);
	}

	return total;
}

/** @param {NS} ns **/
function sortServersByGrowthThreads(ns, serverMap) {
	const hackables = Object.keys(serverMap.servers)
		.filter((hostname) => ns.serverExists(hostname) && ns.hasRootAccess(hostname))
		.filter((hostname) => hostname !== 'home' && !hostname.includes(_settings.baseServer));

	let serversToSort = {};
	for (const server of hackables) {
		serversToSort[server] = getServerMoneyData(ns, server);
	};
	let serverItems = Object.keys(serversToSort).map(function (key) {
		return [key, serversToSort[key]];
	});

	return serverItems.sort(function (a, b) { (b.maxMoney / b.minSecurityLevel + 1 / b.hack10p) - (a.maxMoney / a.minSecurityLevel + 1 / a.hack10p) });
}

/** @param {NS} ns **/
function getMemoryAllotment(ns, hackables) {
	let _hackOn = 0;
	let _growOn = 0;
	let _weakOn = 0;

	for (const server of hackables) {

		let processes = ns.ps(server);

		for (const process of processes) {
			if (process.filename == scripts.hack)
				_hackOn += process.threads;
			if (process.filename == scripts.grow)
				_growOn += process.threads;
			if (process.filename == scripts.weaken)
				_weakOn += process.threads;
		}
	}

	return [_hackOn, _growOn, _weakOn];
}

/** @param {NS} ns **/
function getMemoryAllotmentSpecific(ns, target) {
	let _hackOn = 0;
	let _growOn = 0;
	let _weakOn = 0;

	let processes = ns.ps(target);

	for (const process of processes) {
		if (process.filename == scripts.hack)
			_hackOn += process.threads;
		if (process.filename == scripts.grow)
			_growOn += process.threads;
		if (process.filename == scripts.weaken)
			_weakOn += process.threads;
	}

	return [_hackOn, _growOn, _weakOn];
}

/** @param {NS} ns **/
function getMemoryAllotmentHost(ns, target) {
	let hacks = 0;
	let grows = 0;
	let weakens = 0;
	
	let processes = ns.ps(target);

	for (const process of processes) {
		if (process.args.includes(target)) {
			if (process.filename == scripts.hack)
				hacks += process.threads;
			if (process.filename == scripts.grow)
				grows += process.threads;
			if (process.filename == scripts.weaken)
				weakens += process.threads;
		}
	}

	return [hacks, grows, weakens];
}

/** @param {NS} ns **/
function getTaskValid (ns, task, host) {
	let data = getServerMoneyData(ns, host);
	// ns.print(`Checking if Task is Valid: ${task} for ${host}\n\t${data.moneyPercent}`);

	if (data.moneyMax < _settings.maxAcceptableMoney)
		return false;
	if (data.hackChance < 20.00)
		return false;
	if (ns.getServerRequiredHackingLevel(host) > ns.getHackingLevel())
		return false;

	switch (task) {
		case scripts.hack: {
			// Check if host has enough money to steal
			return data.moneyPercent > 90.00;
		}
		case scripts.grow: {
			// Check if host is low enough on money to grow
			return data.moneyPercent < 95.00;
		}
		case scripts.weaken: {
			// Just weaken everyone - temp
			// TODO: Check if a grow/hack was used then do 1 weaken for
			//	hack and 2 for grow min
			let secLevel = ns.getServerSecurityLevel(host) - ns.getServerMinSecurityLevel(host);
			return secLevel > 0;
		}
		default: return false;
	}
}

/** @param {NS} ns **/
function getTaskLimitForHost (ns, task, host) {
	let data = getServerMoneyData(ns, host);
	let currentRunning = getMemoryAllotmentHost(ns, host);

	switch (task) {
		case scripts.hack: {
			return data.hack10p  - currentRunning[0];
		}
		case scripts.grow: {
			// Not working correcttly!
			// let money = data.maxMoney / data.money;
			// if (money <= 1)
			// 	money = 1;
			// if (isNaN(money))
			// 	return 1;
			// return Math.ceil(ns.growthAnalyze(host, money)) - currentRunning[1];
			return data.growth2x - currentRunning[1];
		}
		case scripts.weaken: {
			const minSec = ns.getServerMinSecurityLevel(host);
			const sec = ns.getServerSecurityLevel(host);
			return Math.ceil((sec - minSec) * 20)  - currentRunning[2];
		}
		default: return 0;
	}
}

/** @param {NS} ns **/
function allotTasks(ns, attacker, defenders, script, taskTotal, taskNum) {
	// Assigns tasks to all servers based on the given target
	let defenderList = [...defenders];
	let consumedTotal = 0;
	

	while (defenderList.length && (consumedTotal < taskTotal)) {
		let defender = defenderList.pop();
			
		if (!getTaskValid(ns, script, defender)) {
			// ns.print(`Failed at: ${script} on ${defenders[0]}... by ${attacker}`);
			continue;
		}

		
		let attackHostLimit = Math.min(taskTotal - taskNum, getTaskLimitForHost(ns, script, defender));

		let max_ram = ns.getServerMaxRam(attacker);
		let used_ram = ns.getServerUsedRam(attacker);
		let useable_ram = max_ram - used_ram;
		let threads = Math.min(Math.floor(useable_ram / ns.getScriptRam(script)), attackHostLimit - consumedTotal);
		if (threads < 1)
			continue;

		ns.exec(script, attacker, threads, defender, 0);

		consumedTotal += threads;
	}

	return consumedTotal;
}

/** @param {NS} ns **/
function doTaskLoop(ns, hostsOfAttack, targetsOfHost, script, taskTotal) {
	// Finds the targets worth and assigns them to the server group
	// ns.print(`Entering function: ${script}`);

	let taskNum = 0;
	let attackers = [...hostsOfAttack];
	let defenders = [...targetsOfHost];
		
	while (attackers.length && (taskNum < taskTotal)) {
		// Check if host can be worked on for current task
		let attacker = attackers.pop();

		let taskThreads = allotTasks(ns, attacker, defenders, script, taskTotal, taskNum);
		taskNum += taskThreads;
	}

	return taskNum;
}

/** @param {NS} ns **/
function getHackableServers(ns, servers) {
	const playerDetails = getPlayer(ns);

	const hackableServers = Object.keys(servers.servers)
		.filter((hostname) => ns.serverExists(hostname))
		.filter((hostname) => servers.servers[hostname].ports <= playerDetails.portCount || ns.hasRootAccess(hostname))
		.map((hostname) => {
		  if (hostname.host !== 'home') {
		    if (!ns.hasRootAccess(hostname)) {
		      hackPrograms.forEach((hackProgram) => {
		        if (ns.fileExists(hackProgram, 'home')) {
		          ns[hackProgram.split('.').shift().toLocaleLowerCase()](hostname)
		        }
		      })
		      ns.nuke(hostname)
		    }
		  }
		  return hostname
		})
		.filter((hostname) => hostname.ram >= 2);

	// ns.print(hackableServers);
	hackableServers.sort((a, b) => a.ram - b.ram);

	return hackableServers;
}

/** @param {NS} ns **/
export async function main(ns) {
	ns.disableLog('ALL');

	var canRun = true;
	var shouldKill = ns.args[0];

	if (!shouldKill || shouldKill != "y")
		shouldKill = false;
	else
		shouldKill = true;

	ns.print(`Starting manager.ns at [${localeHHMMSS()}]\n`);

	//let portsOpen = portsAbleToOpen();
	let hostname = ns.getHostname();
	if (hostname !== 'home') {
		throw new Exception('Run script from home');
	}

	// 1. Load all servers from serverMap
	ns.run(scripts.findServer, 1);
	ns.print(`Finished Server Pings.\n`);

	// 2. Kill all scripts on target servers that manager is not managing
	if (shouldKill)
		ns.run(scripts.killall, 1);

	// 3, populate serverMap
	let serverMap = getItem(_settings.keys.serverMap);
	ns.print(`Finished Server Population.\n`);

	// 4. Open all servers, also transfers files need for further development
	getHackableServers(ns, serverMap);
	let hackables = Object.keys(serverMap.servers)
		.filter((hostname) => ns.hasRootAccess(hostname))
		.filter((hostname) => hostname !== 'home');	
	ns.print(`Finished Opening All Servers.\n${hackables}\nSleeping for ${_settings.timeout_after}\n`);
	await ns.sleep(_settings.timeout_after);

	// 5. Transfer all needed files to servers
	const files = [scripts.weaken, scripts.grow, scripts.hack];
	for (const server of hackables) {
		for (const file of files)
			try {
				// ns.print(`${file}`)
				let pid = ns.run(scripts.transfer, 1, server, file);
				// ns.print(`Transfer started at: ${pid}\n`);
				await ns.sleep(_settings.timeout);
			}
			catch (err) {
				ns.print(`Unable to transfer files error: ${err}\n`);
			}
	}
	ns.print(`Finished transfering All files to servers.\nHackables: ${hackables}\nSleeping for ${_settings.timeout_after}\n`);
	await ns.sleep(_settings.timeout_after);

	// Main Loop logic
	const startTime = localeHHMMSS();
	const hackCost = ns.getScriptRam(scripts.hack);
	const growCost = ns.getScriptRam(scripts.grow);
	const weakenCost = ns.getScriptRam(scripts.weaken);

	let hackOn = 0;
	let growOn = 0;
	let weakOn = 0;

	let hackOnHome = 0;
	let growOnHome = 0;
	let weakOnHome = 0;
	
	// Get total memory usable
	const totalMemAvailable = getTotalMemory(ns, serverMap);
	const hackCap = Math.floor(totalMemAvailable * _settings.hackAllotment / hackCost);
	const growCap = Math.floor(totalMemAvailable * _settings.growAllotment / growCost);
	const weakenCap = Math.floor(totalMemAvailable * _settings.weakenAllotment / weakenCost);


	// Get total memory usable on home
	const totalMemAvailableHome = ns.getServerMaxRam('home') - 64;
	const hackCapHome = Math.floor(totalMemAvailableHome * _settings.hackAllotment / hackCost);
	const growCapHome = Math.floor(totalMemAvailableHome * _settings.growAllotment / growCost);
	const weakenCapHome = Math.floor(totalMemAvailableHome * _settings.weakenAllotment / weakenCost);

	let iterOnOpen = 0;
	
	let home_server = ['home',];

	ns.print(`Starting main loop.\n`);
	while (canRun) {
		// // Restart script if run for over a day
		// if (new Date().getTime() - startTime > _settings.mapRefreshInterval) {
		// 	ns.spawn(`${_settings.baseLocation}manager.ns`, 1, 'n');
		// 	ns.exit();
		// }

		// Count all scripts running
		let memValues = getMemoryAllotment(ns, hackables);
		hackOn = memValues[0];
		growOn = memValues[1];
		weakOn = memValues[2];

		// Count all scripts running
		let memValuesHome = getMemoryAllotmentSpecific(ns, 'home');
		hackOnHome = memValuesHome[0];
		growOnHome = memValuesHome[1];
		weakOnHome = memValuesHome[2];

		// On the servers with root acccess assess what can be done to them
		const sortedServers = sortServersByGrowthThreads(ns, serverMap);
		let dictSortedServers = {};
		for (const values of sortedServers) {
			dictSortedServers[values[0]] = {};
			for (const value in values[1]) {
				dictSortedServers[values[0]][value] = values[1][value];
			}
		}
		let namesOfSortedServers = sortedServers
			.map((host) => {
				return host[0];
			});

		// Assign jobs based on settings for weaken, hack and grow
		// First steal from all possible with less then 10
		// Turned into function
		// Total of memory used for this hack on this server
		let hacksMaxThreads = hackCap - hackOn;
		let hack_tasks = doTaskLoop(ns, hackables, namesOfSortedServers, scripts.hack, hacksMaxThreads);

		// Second grow from all possible
		let growsMaxThreads = growCap - growOn + hacksMaxThreads - hack_tasks;
		let grow_tasks = doTaskLoop(ns, hackables, namesOfSortedServers, scripts.grow, growsMaxThreads);

		// Third weaken any possible
		let weaksMaxThreads = weakenCap - weakOn + growsMaxThreads - grow_tasks;
		let weak_tasks = doTaskLoop(ns, hackables, namesOfSortedServers, scripts.weaken, weaksMaxThreads);

		// Add tasks for home		
		// Total of memory used for this hack on this server
		let hackHThreads = hackCapHome - hackOnHome;
		let hack_h_tasks = doTaskLoop(ns, home_server, namesOfSortedServers, scripts.hack, hackHThreads);

		// Second grow from all possible
		let growHThreads = growCapHome - growOnHome + hackHThreads - hack_h_tasks;
		let grow_h_tasks = doTaskLoop(ns, home_server, namesOfSortedServers, scripts.grow, growHThreads);

		// Third weaken any possible
		let weakHThreads = weakenCapHome - weakOnHome + growHThreads - grow_h_tasks;
		let weak_h_tasks = doTaskLoop(ns, home_server, namesOfSortedServers, scripts.weaken, weakHThreads);

		ns.clearLog();
		ns.print("--------------------------");
		ns.print(`Hacks On: ${(hackOn / hackCap * 100).toFixed(2)}`);
		ns.print(`Grow On: ${(growOn / growCap * 100).toFixed(2)}`);
		ns.print(`Weaken On: ${(weakOn / weakenCap * 100).toFixed(2)}`);
		ns.print("--------------------------");
		await ns.sleep(_settings.loopRunTime);

		iterOnOpen++;
		if (iterOnOpen > 2) {
			// ns.print(`Attempting to open more servers!`)
			iterOnOpen = 0;
			getHackableServers(ns, serverMap);
			hackables = Object.keys(serverMap.servers)
				.filter((hostname) => ns.hasRootAccess(hostname))
				.filter((hostname) => hostname !== 'home');	
			
			ns.run(scripts.findServer, 1);
			serverMap = getItem(_settings.keys.serverMap);
		}
	}
}